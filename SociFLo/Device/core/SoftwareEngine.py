#works as conceptual delimitation of software bounds.
from typing import Dict
import json
import core.HW.routeIO((, ))
jys = shell()
class shell:
    def run():
        print(""" SoftwareEngine Shell: \n  (c)ommands... \n  """)
class HWPage():
    def __init__(self, id) -> None:
        #super().__init__()
        #data = bytearray()
        self.XHeader = json.load(id+".appmanifest")


class softwarePack(software):
    def __init__(self, id):
        hwPage = genHWPage(self)
        self.forms = {"ExecuteStack": [],
                        }q
        self.Memory = RAMRESERVE(type = 0, len=hwPage.max_mem)
        self.SieveSET = 
        self.OPS # generation of this scheme outside haskell bounds so.. maybe double-work. ops nice like this though, systemic exterior OS operating verifiably.- continue.

    def genHWPage(): # this needs hashed and as cold contingency
        #Delimit & return HW operations and contingencies & execute perched operation; Builds a report of execute range of superceding softwarePack
            #hw-deviceinghashops = derivative~..
        #pack_poll: hardware_calls.:


